{"ast":null,"code":"export class CommonValidator {\n  static async validate(value, validators) {\n    let validationResult = null;\n    let i = 0;\n    while (validationResult === null && i < validators.length) {\n      const result = await validators[i](value);\n      result && (validationResult = result);\n      i++;\n    }\n    return validationResult;\n  }\n}\n\n// export class Validator {\n//     defaultData: ValidatorData;\n//\n//     constructor(defaultData: ValidatorData) {\n//         this.defaultData = defaultData;\n//     }\n//\n//     validate(data: ValidatorData): Partial<ValidatorData> {\n//         const errors: Partial<ValidatorData> = {};\n//\n//         for(const key in data) {\n//             const error = this.getError(data[key] as string[]);\n//             if(error) {\n//                 errors[key] = error;\n//             }\n//         }\n//\n//         return errors;\n//     }\n//\n//     private getError(errors: string[]): string {\n//         return errors[0];\n//     }\n//\n//     hasError(errors: Partial<ValidatorData>) {\n//         for(const key in errors) {\n//             if(errors[key]) {\n//                 return true;\n//             }\n//         }\n//\n//         return false;\n//     }\n//\n//     protected required(value: string) {\n//         const errors: string[] = [];\n//\n//         if(!value.length && errors.push(\"Поле обязательно\")) {\n//             return errors;\n//         }\n//\n//         const regex = /(<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\n//         if(regex.test(value)) {\n//             errors.push(\"Обнаружены недопустимые символы\");\n//         }\n//\n//         return errors;\n//     }\n// }\n\n// export class Validator {\n//     validate(data: Object) {\n//         const errors: Partial<IValidatorData> = {};\n//\n//         for(const key in data) {\n//             const error = this.getError(data[key] as string[]);\n//             if(error) {\n//                 errors[key] = error;\n//             }\n//         }\n//\n//         return errors;\n//     }\n//\n//     static getError(errors: string[]) {\n//         return errors[0];\n//     }\n//\n//     static hasError(errors: IValidatorData) {\n//         for(const key in errors) {\n//             if(errors[key]) {\n//                 return true;\n//             }\n//         }\n//\n//         return false;\n//     }\n//\n//     static required(value: string) {\n//         const errors: string[] = [];\n//\n//         if(!value.length && errors.push(\"Поле обязательно\")) {\n//             return errors;\n//         }\n//\n//         const regex = /(<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\n//         if(regex.test(value)) {\n//             errors.push(\"Обнаружены недопустимые символы\");\n//         }\n//\n//         return errors;\n//     }\n// }\nCommonValidator.required = (message = \"Поле обязательно\") => {\n  return async value => value ? null : message;\n};","map":{"version":3,"names":["CommonValidator","validate","value","validators","validationResult","i","length","result","required","message"],"sources":["D:/Mega/Planner/frontend/src/shared/lib/validator/base.ts"],"sourcesContent":["import {ValidatorData, Validator, ValidationResult, GetValidator} from \"./models\";\r\n\r\nexport class CommonValidator {\r\n    static async validate<T>(\r\n        value: T,\r\n        validators: Validator<T>[]\r\n    ): Promise<ValidationResult> {\r\n        let validationResult: ValidationResult = null;\r\n        let i = 0;\r\n\r\n        while(validationResult === null && i < validators.length) {\r\n            const result = await validators[i](value);\r\n\r\n            result && (validationResult = result);\r\n            i++;\r\n        }\r\n\r\n        return validationResult;\r\n    }\r\n\r\n    static required: GetValidator<string, string> = (\r\n        message = \"Поле обязательно\"\r\n    ) => {\r\n        return async (value) => (value ? null : message);\r\n    }\r\n}\r\n\r\n// export class Validator {\r\n//     defaultData: ValidatorData;\r\n//\r\n//     constructor(defaultData: ValidatorData) {\r\n//         this.defaultData = defaultData;\r\n//     }\r\n//\r\n//     validate(data: ValidatorData): Partial<ValidatorData> {\r\n//         const errors: Partial<ValidatorData> = {};\r\n//\r\n//         for(const key in data) {\r\n//             const error = this.getError(data[key] as string[]);\r\n//             if(error) {\r\n//                 errors[key] = error;\r\n//             }\r\n//         }\r\n//\r\n//         return errors;\r\n//     }\r\n//\r\n//     private getError(errors: string[]): string {\r\n//         return errors[0];\r\n//     }\r\n//\r\n//     hasError(errors: Partial<ValidatorData>) {\r\n//         for(const key in errors) {\r\n//             if(errors[key]) {\r\n//                 return true;\r\n//             }\r\n//         }\r\n//\r\n//         return false;\r\n//     }\r\n//\r\n//     protected required(value: string) {\r\n//         const errors: string[] = [];\r\n//\r\n//         if(!value.length && errors.push(\"Поле обязательно\")) {\r\n//             return errors;\r\n//         }\r\n//\r\n//         const regex = /(<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\r\n//         if(regex.test(value)) {\r\n//             errors.push(\"Обнаружены недопустимые символы\");\r\n//         }\r\n//\r\n//         return errors;\r\n//     }\r\n// }\r\n\r\n// export class Validator {\r\n//     validate(data: Object) {\r\n//         const errors: Partial<IValidatorData> = {};\r\n//\r\n//         for(const key in data) {\r\n//             const error = this.getError(data[key] as string[]);\r\n//             if(error) {\r\n//                 errors[key] = error;\r\n//             }\r\n//         }\r\n//\r\n//         return errors;\r\n//     }\r\n//\r\n//     static getError(errors: string[]) {\r\n//         return errors[0];\r\n//     }\r\n//\r\n//     static hasError(errors: IValidatorData) {\r\n//         for(const key in errors) {\r\n//             if(errors[key]) {\r\n//                 return true;\r\n//             }\r\n//         }\r\n//\r\n//         return false;\r\n//     }\r\n//\r\n//     static required(value: string) {\r\n//         const errors: string[] = [];\r\n//\r\n//         if(!value.length && errors.push(\"Поле обязательно\")) {\r\n//             return errors;\r\n//         }\r\n//\r\n//         const regex = /(<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\r\n//         if(regex.test(value)) {\r\n//             errors.push(\"Обнаружены недопустимые символы\");\r\n//         }\r\n//\r\n//         return errors;\r\n//     }\r\n// }"],"mappings":"AAEA,OAAO,MAAMA,eAAe,CAAC;EACzB,aAAaC,QAAQA,CACjBC,KAAQ,EACRC,UAA0B,EACD;IACzB,IAAIC,gBAAkC,GAAG,IAAI;IAC7C,IAAIC,CAAC,GAAG,CAAC;IAET,OAAMD,gBAAgB,KAAK,IAAI,IAAIC,CAAC,GAAGF,UAAU,CAACG,MAAM,EAAE;MACtD,MAAMC,MAAM,GAAG,MAAMJ,UAAU,CAACE,CAAC,CAAC,CAACH,KAAK,CAAC;MAEzCK,MAAM,KAAKH,gBAAgB,GAAGG,MAAM,CAAC;MACrCF,CAAC,EAAE;IACP;IAEA,OAAOD,gBAAgB;EAC3B;AAOJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArHaJ,eAAe,CAkBjBQ,QAAQ,GAAiC,CAC5CC,OAAO,GAAG,kBAAkB,KAC3B;EACD,OAAO,MAAOP,KAAK,IAAMA,KAAK,GAAG,IAAI,GAAGO,OAAQ;AACpD,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}