{"ast":null,"code":"export class CommonValidator {}\nexport class Validator {\n  constructor(defaultData) {\n    this.defaultData = void 0;\n    this.defaultData = defaultData;\n  }\n  validate(data) {\n    const errors = {};\n    for (const key in data) {\n      const error = this.getError(data[key]);\n      if (error) {\n        errors[key] = error;\n      }\n    }\n    return errors;\n  }\n  getError(errors) {\n    return errors[0];\n  }\n  hasError(errors) {\n    for (const key in errors) {\n      if (errors[key]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  required(value) {\n    const errors = [];\n    if (!value.length && errors.push(\"Поле обязательно\")) {\n      return errors;\n    }\n    const regex = /(<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\n    if (regex.test(value)) {\n      errors.push(\"Обнаружены недопустимые символы\");\n    }\n    return errors;\n  }\n}\n\n// export class Validator {\n//     validate(data: Object) {\n//         const errors: Partial<IValidatorData> = {};\n//\n//         for(const key in data) {\n//             const error = this.getError(data[key] as string[]);\n//             if(error) {\n//                 errors[key] = error;\n//             }\n//         }\n//\n//         return errors;\n//     }\n//\n//     static getError(errors: string[]) {\n//         return errors[0];\n//     }\n//\n//     static hasError(errors: IValidatorData) {\n//         for(const key in errors) {\n//             if(errors[key]) {\n//                 return true;\n//             }\n//         }\n//\n//         return false;\n//     }\n//\n//     static required(value: string) {\n//         const errors: string[] = [];\n//\n//         if(!value.length && errors.push(\"Поле обязательно\")) {\n//             return errors;\n//         }\n//\n//         const regex = /(<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\n//         if(regex.test(value)) {\n//             errors.push(\"Обнаружены недопустимые символы\");\n//         }\n//\n//         return errors;\n//     }\n// }","map":{"version":3,"names":["CommonValidator","Validator","constructor","defaultData","validate","data","errors","key","error","getError","hasError","required","value","length","push","regex","test"],"sources":["D:/Mega/Planner/frontend/src/shared/lib/validator/base.ts"],"sourcesContent":["import { ValidatorData } from \"./models\";\r\n\r\nexport class CommonValidator {\r\n    static async validate<T>(\r\n        value: T,\r\n        validators\r\n    )\r\n}\r\n\r\nexport class Validator {\r\n    defaultData: ValidatorData;\r\n\r\n    constructor(defaultData: ValidatorData) {\r\n        this.defaultData = defaultData;\r\n    }\r\n\r\n    validate(data: ValidatorData): Partial<ValidatorData> {\r\n        const errors: Partial<ValidatorData> = {};\r\n\r\n        for(const key in data) {\r\n            const error = this.getError(data[key] as string[]);\r\n            if(error) {\r\n                errors[key] = error;\r\n            }\r\n        }\r\n\r\n        return errors;\r\n    }\r\n\r\n    private getError(errors: string[]): string {\r\n        return errors[0];\r\n    }\r\n\r\n    hasError(errors: Partial<ValidatorData>) {\r\n        for(const key in errors) {\r\n            if(errors[key]) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    protected required(value: string) {\r\n        const errors: string[] = [];\r\n\r\n        if(!value.length && errors.push(\"Поле обязательно\")) {\r\n            return errors;\r\n        }\r\n\r\n        const regex = /(<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\r\n        if(regex.test(value)) {\r\n            errors.push(\"Обнаружены недопустимые символы\");\r\n        }\r\n\r\n        return errors;\r\n    }\r\n}\r\n\r\n// export class Validator {\r\n//     validate(data: Object) {\r\n//         const errors: Partial<IValidatorData> = {};\r\n//\r\n//         for(const key in data) {\r\n//             const error = this.getError(data[key] as string[]);\r\n//             if(error) {\r\n//                 errors[key] = error;\r\n//             }\r\n//         }\r\n//\r\n//         return errors;\r\n//     }\r\n//\r\n//     static getError(errors: string[]) {\r\n//         return errors[0];\r\n//     }\r\n//\r\n//     static hasError(errors: IValidatorData) {\r\n//         for(const key in errors) {\r\n//             if(errors[key]) {\r\n//                 return true;\r\n//             }\r\n//         }\r\n//\r\n//         return false;\r\n//     }\r\n//\r\n//     static required(value: string) {\r\n//         const errors: string[] = [];\r\n//\r\n//         if(!value.length && errors.push(\"Поле обязательно\")) {\r\n//             return errors;\r\n//         }\r\n//\r\n//         const regex = /(<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\r\n//         if(regex.test(value)) {\r\n//             errors.push(\"Обнаружены недопустимые символы\");\r\n//         }\r\n//\r\n//         return errors;\r\n//     }\r\n// }"],"mappings":"AAEA,OAAO,MAAMA,eAAe,CAAC;AAO7B,OAAO,MAAMC,SAAS,CAAC;EAGnBC,WAAWA,CAACC,WAA0B,EAAE;IAAA,KAFxCA,WAAW;IAGP,IAAI,CAACA,WAAW,GAAGA,WAAW;EAClC;EAEAC,QAAQA,CAACC,IAAmB,EAA0B;IAClD,MAAMC,MAA8B,GAAG,CAAC,CAAC;IAEzC,KAAI,MAAMC,GAAG,IAAIF,IAAI,EAAE;MACnB,MAAMG,KAAK,GAAG,IAAI,CAACC,QAAQ,CAACJ,IAAI,CAACE,GAAG,CAAa,CAAC;MAClD,IAAGC,KAAK,EAAE;QACNF,MAAM,CAACC,GAAG,CAAC,GAAGC,KAAK;MACvB;IACJ;IAEA,OAAOF,MAAM;EACjB;EAEQG,QAAQA,CAACH,MAAgB,EAAU;IACvC,OAAOA,MAAM,CAAC,CAAC,CAAC;EACpB;EAEAI,QAAQA,CAACJ,MAA8B,EAAE;IACrC,KAAI,MAAMC,GAAG,IAAID,MAAM,EAAE;MACrB,IAAGA,MAAM,CAACC,GAAG,CAAC,EAAE;QACZ,OAAO,IAAI;MACf;IACJ;IAEA,OAAO,KAAK;EAChB;EAEUI,QAAQA,CAACC,KAAa,EAAE;IAC9B,MAAMN,MAAgB,GAAG,EAAE;IAE3B,IAAG,CAACM,KAAK,CAACC,MAAM,IAAIP,MAAM,CAACQ,IAAI,CAAC,kBAAkB,CAAC,EAAE;MACjD,OAAOR,MAAM;IACjB;IAEA,MAAMS,KAAK,GAAG,4CAA4C;IAC1D,IAAGA,KAAK,CAACC,IAAI,CAACJ,KAAK,CAAC,EAAE;MAClBN,MAAM,CAACQ,IAAI,CAAC,iCAAiC,CAAC;IAClD;IAEA,OAAOR,MAAM;EACjB;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}